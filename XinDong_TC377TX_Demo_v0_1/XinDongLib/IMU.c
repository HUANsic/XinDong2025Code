#include "IMU.h"
#include "Display.h"
#include "Time.h"

#define MPU6050_OMEGA_INT_THRESHOLD 0.03

#define MPU6050_ADDR 0xD0

#define SMPLRT_DIV_REG 0x19
#define GYRO_CONFIG_REG 0x1B
#define ACCEL_CONFIG_REG 0x1C
#define ACCEL_XOUT_H_REG 0x3B
#define TEMP_OUT_H_REG 0x41
#define GYRO_XOUT_H_REG 0x43
#define PWR_MGMT_1_REG 0x6B
#define WHO_AM_I_REG 0x75

float accel[3], omega[3], theta[3], accel_offset[3], omega_offset[3], theta_offset[3];

EI2C_Typedef MPU6050_I2C_Struct;

uint8 dmpmemorydata[1929]={
 // bank 0, 256 bytes
    0xFB, 0x00, 0x00, 0x3E, 0x00, 0x0B, 0x00, 0x36, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03, 0x00, 0x00,
    0x00, 0x65, 0x00, 0x54, 0xFF, 0xEF, 0x00, 0x00, 0xFA, 0x80, 0x00, 0x0B, 0x12, 0x82, 0x00, 0x01,
    0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x28, 0x00, 0x00, 0xFF, 0xFF, 0x45, 0x81, 0xFF, 0xFF, 0xFA, 0x72, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x03, 0xE8, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x7F, 0xFF, 0xFF, 0xFE, 0x80, 0x01,
    0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x3E, 0x03, 0x30, 0x40, 0x00, 0x00, 0x00, 0x02, 0xCA, 0xE3, 0x09, 0x3E, 0x80, 0x00, 0x00,
    0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
    0x41, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x2A, 0x00, 0x00, 0x16, 0x55, 0x00, 0x00, 0x21, 0x82,
    0xFD, 0x87, 0x26, 0x50, 0xFD, 0x80, 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x05, 0x80, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
    0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x6F, 0x00, 0x02, 0x65, 0x32, 0x00, 0x00, 0x5E, 0xC0,
    0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFB, 0x8C, 0x6F, 0x5D, 0xFD, 0x5D, 0x08, 0xD9, 0x00, 0x7C, 0x73, 0x3B, 0x00, 0x6C, 0x12, 0xCC,
    0x32, 0x00, 0x13, 0x9D, 0x32, 0x00, 0xD0, 0xD6, 0x32, 0x00, 0x08, 0x00, 0x40, 0x00, 0x01, 0xF4,
    0xFF, 0xE6, 0x80, 0x79, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD0, 0xD6, 0x00, 0x00, 0x27, 0x10,
    // bank 1, 256 bytes
    0xFB, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFA, 0x36, 0xFF, 0xBC, 0x30, 0x8E, 0x00, 0x05, 0xFB, 0xF0, 0xFF, 0xD9, 0x5B, 0xC8,
    0xFF, 0xD0, 0x9A, 0xBE, 0x00, 0x00, 0x10, 0xA9, 0xFF, 0xF4, 0x1E, 0xB2, 0x00, 0xCE, 0xBB, 0xF7,
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x02, 0x00, 0x02, 0x02, 0x00, 0x00, 0x0C,
    0xFF, 0xC2, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0xCF, 0x80, 0x00, 0x40, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x14,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x03, 0x3F, 0x68, 0xB6, 0x79, 0x35, 0x28, 0xBC, 0xC6, 0x7E, 0xD1, 0x6C,
    0x80, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB2, 0x6A, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xF0, 0x00, 0x00, 0x00, 0x30,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x25, 0x4D, 0x00, 0x2F, 0x70, 0x6D, 0x00, 0x00, 0x05, 0xAE, 0x00, 0x0C, 0x02, 0xD0,
    // bank 2, 256 bytes
    0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x00, 0x54, 0xFF, 0xEF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x01, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x01, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0xFF, 0xEF, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
    0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // bank 3, 256 bytes
    0xD8, 0xDC, 0xBA, 0xA2, 0xF1, 0xDE, 0xB2, 0xB8, 0xB4, 0xA8, 0x81, 0x91, 0xF7, 0x4A, 0x90, 0x7F,
    0x91, 0x6A, 0xF3, 0xF9, 0xDB, 0xA8, 0xF9, 0xB0, 0xBA, 0xA0, 0x80, 0xF2, 0xCE, 0x81, 0xF3, 0xC2,
    0xF1, 0xC1, 0xF2, 0xC3, 0xF3, 0xCC, 0xA2, 0xB2, 0x80, 0xF1, 0xC6, 0xD8, 0x80, 0xBA, 0xA7, 0xDF,
    0xDF, 0xDF, 0xF2, 0xA7, 0xC3, 0xCB, 0xC5, 0xB6, 0xF0, 0x87, 0xA2, 0x94, 0x24, 0x48, 0x70, 0x3C,
    0x95, 0x40, 0x68, 0x34, 0x58, 0x9B, 0x78, 0xA2, 0xF1, 0x83, 0x92, 0x2D, 0x55, 0x7D, 0xD8, 0xB1,
    0xB4, 0xB8, 0xA1, 0xD0, 0x91, 0x80, 0xF2, 0x70, 0xF3, 0x70, 0xF2, 0x7C, 0x80, 0xA8, 0xF1, 0x01,
    0xB0, 0x98, 0x87, 0xD9, 0x43, 0xD8, 0x86, 0xC9, 0x88, 0xBA, 0xA1, 0xF2, 0x0E, 0xB8, 0x97, 0x80,
    0xF1, 0xA9, 0xDF, 0xDF, 0xDF, 0xAA, 0xDF, 0xDF, 0xDF, 0xF2, 0xAA, 0xC5, 0xCD, 0xC7, 0xA9, 0x0C,
    0xC9, 0x2C, 0x97, 0x97, 0x97, 0x97, 0xF1, 0xA9, 0x89, 0x26, 0x46, 0x66, 0xB0, 0xB4, 0xBA, 0x80,
    0xAC, 0xDE, 0xF2, 0xCA, 0xF1, 0xB2, 0x8C, 0x02, 0xA9, 0xB6, 0x98, 0x00, 0x89, 0x0E, 0x16, 0x1E,
    0xB8, 0xA9, 0xB4, 0x99, 0x2C, 0x54, 0x7C, 0xB0, 0x8A, 0xA8, 0x96, 0x36, 0x56, 0x76, 0xF1, 0xB9,
    0xAF, 0xB4, 0xB0, 0x83, 0xC0, 0xB8, 0xA8, 0x97, 0x11, 0xB1, 0x8F, 0x98, 0xB9, 0xAF, 0xF0, 0x24,
    0x08, 0x44, 0x10, 0x64, 0x18, 0xF1, 0xA3, 0x29, 0x55, 0x7D, 0xAF, 0x83, 0xB5, 0x93, 0xAF, 0xF0,
    0x00, 0x28, 0x50, 0xF1, 0xA3, 0x86, 0x9F, 0x61, 0xA6, 0xDA, 0xDE, 0xDF, 0xD9, 0xFA, 0xA3, 0x86,
    0x96, 0xDB, 0x31, 0xA6, 0xD9, 0xF8, 0xDF, 0xBA, 0xA6, 0x8F, 0xC2, 0xC5, 0xC7, 0xB2, 0x8C, 0xC1,
    0xB8, 0xA2, 0xDF, 0xDF, 0xDF, 0xA3, 0xDF, 0xDF, 0xDF, 0xD8, 0xD8, 0xF1, 0xB8, 0xA8, 0xB2, 0x86,
    // bank 4, 256 bytes
    0xB4, 0x98, 0x0D, 0x35, 0x5D, 0xB8, 0xAA, 0x98, 0xB0, 0x87, 0x2D, 0x35, 0x3D, 0xB2, 0xB6, 0xBA,
    0xAF, 0x8C, 0x96, 0x19, 0x8F, 0x9F, 0xA7, 0x0E, 0x16, 0x1E, 0xB4, 0x9A, 0xB8, 0xAA, 0x87, 0x2C,
    0x54, 0x7C, 0xB9, 0xA3, 0xDE, 0xDF, 0xDF, 0xA3, 0xB1, 0x80, 0xF2, 0xC4, 0xCD, 0xC9, 0xF1, 0xB8,
    0xA9, 0xB4, 0x99, 0x83, 0x0D, 0x35, 0x5D, 0x89, 0xB9, 0xA3, 0x2D, 0x55, 0x7D, 0xB5, 0x93, 0xA3,
    0x0E, 0x16, 0x1E, 0xA9, 0x2C, 0x54, 0x7C, 0xB8, 0xB4, 0xB0, 0xF1, 0x97, 0x83, 0xA8, 0x11, 0x84,
    0xA5, 0x09, 0x98, 0xA3, 0x83, 0xF0, 0xDA, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0xD8, 0xF1, 0xA5,
    0x29, 0x55, 0x7D, 0xA5, 0x85, 0x95, 0x02, 0x1A, 0x2E, 0x3A, 0x56, 0x5A, 0x40, 0x48, 0xF9, 0xF3,
    0xA3, 0xD9, 0xF8, 0xF0, 0x98, 0x83, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0x97, 0x82, 0xA8, 0xF1,
    0x11, 0xF0, 0x98, 0xA2, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0xDA, 0xF3, 0xDE, 0xD8, 0x83, 0xA5,
    0x94, 0x01, 0xD9, 0xA3, 0x02, 0xF1, 0xA2, 0xC3, 0xC5, 0xC7, 0xD8, 0xF1, 0x84, 0x92, 0xA2, 0x4D,
    0xDA, 0x2A, 0xD8, 0x48, 0x69, 0xD9, 0x2A, 0xD8, 0x68, 0x55, 0xDA, 0x32, 0xD8, 0x50, 0x71, 0xD9,
    0x32, 0xD8, 0x70, 0x5D, 0xDA, 0x3A, 0xD8, 0x58, 0x79, 0xD9, 0x3A, 0xD8, 0x78, 0x93, 0xA3, 0x4D,
    0xDA, 0x2A, 0xD8, 0x48, 0x69, 0xD9, 0x2A, 0xD8, 0x68, 0x55, 0xDA, 0x32, 0xD8, 0x50, 0x71, 0xD9,
    0x32, 0xD8, 0x70, 0x5D, 0xDA, 0x3A, 0xD8, 0x58, 0x79, 0xD9, 0x3A, 0xD8, 0x78, 0xA8, 0x8A, 0x9A,
    0xF0, 0x28, 0x50, 0x78, 0x9E, 0xF3, 0x88, 0x18, 0xF1, 0x9F, 0x1D, 0x98, 0xA8, 0xD9, 0x08, 0xD8,
    0xC8, 0x9F, 0x12, 0x9E, 0xF3, 0x15, 0xA8, 0xDA, 0x12, 0x10, 0xD8, 0xF1, 0xAF, 0xC8, 0x97, 0x87,
    // bank 5, 256 bytes
    0x34, 0xB5, 0xB9, 0x94, 0xA4, 0x21, 0xF3, 0xD9, 0x22, 0xD8, 0xF2, 0x2D, 0xF3, 0xD9, 0x2A, 0xD8,
    0xF2, 0x35, 0xF3, 0xD9, 0x32, 0xD8, 0x81, 0xA4, 0x60, 0x60, 0x61, 0xD9, 0x61, 0xD8, 0x6C, 0x68,
    0x69, 0xD9, 0x69, 0xD8, 0x74, 0x70, 0x71, 0xD9, 0x71, 0xD8, 0xB1, 0xA3, 0x84, 0x19, 0x3D, 0x5D,
    0xA3, 0x83, 0x1A, 0x3E, 0x5E, 0x93, 0x10, 0x30, 0x81, 0x10, 0x11, 0xB8, 0xB0, 0xAF, 0x8F, 0x94,
    0xF2, 0xDA, 0x3E, 0xD8, 0xB4, 0x9A, 0xA8, 0x87, 0x29, 0xDA, 0xF8, 0xD8, 0x87, 0x9A, 0x35, 0xDA,
    0xF8, 0xD8, 0x87, 0x9A, 0x3D, 0xDA, 0xF8, 0xD8, 0xB1, 0xB9, 0xA4, 0x98, 0x85, 0x02, 0x2E, 0x56,
    0xA5, 0x81, 0x00, 0x0C, 0x14, 0xA3, 0x97, 0xB0, 0x8A, 0xF1, 0x2D, 0xD9, 0x28, 0xD8, 0x4D, 0xD9,
    0x48, 0xD8, 0x6D, 0xD9, 0x68, 0xD8, 0xB1, 0x84, 0x0D, 0xDA, 0x0E, 0xD8, 0xA3, 0x29, 0x83, 0xDA,
    0x2C, 0x0E, 0xD8, 0xA3, 0x84, 0x49, 0x83, 0xDA, 0x2C, 0x4C, 0x0E, 0xD8, 0xB8, 0xB0, 0xA8, 0x8A,
    0x9A, 0xF5, 0x20, 0xAA, 0xDA, 0xDF, 0xD8, 0xA8, 0x40, 0xAA, 0xD0, 0xDA, 0xDE, 0xD8, 0xA8, 0x60,
    0xAA, 0xDA, 0xD0, 0xDF, 0xD8, 0xF1, 0x97, 0x86, 0xA8, 0x31, 0x9B, 0x06, 0x99, 0x07, 0xAB, 0x97,
    0x28, 0x88, 0x9B, 0xF0, 0x0C, 0x20, 0x14, 0x40, 0xB8, 0xB0, 0xB4, 0xA8, 0x8C, 0x9C, 0xF0, 0x04,
    0x28, 0x51, 0x79, 0x1D, 0x30, 0x14, 0x38, 0xB2, 0x82, 0xAB, 0xD0, 0x98, 0x2C, 0x50, 0x50, 0x78,
    0x78, 0x9B, 0xF1, 0x1A, 0xB0, 0xF0, 0x8A, 0x9C, 0xA8, 0x29, 0x51, 0x79, 0x8B, 0x29, 0x51, 0x79,
    0x8A, 0x24, 0x70, 0x59, 0x8B, 0x20, 0x58, 0x71, 0x8A, 0x44, 0x69, 0x38, 0x8B, 0x39, 0x40, 0x68,
    0x8A, 0x64, 0x48, 0x31, 0x8B, 0x30, 0x49, 0x60, 0xA5, 0x88, 0x20, 0x09, 0x71, 0x58, 0x44, 0x68,
    // bank 6, 256 bytes
    0x11, 0x39, 0x64, 0x49, 0x30, 0x19, 0xF1, 0xAC, 0x00, 0x2C, 0x54, 0x7C, 0xF0, 0x8C, 0xA8, 0x04,
    0x28, 0x50, 0x78, 0xF1, 0x88, 0x97, 0x26, 0xA8, 0x59, 0x98, 0xAC, 0x8C, 0x02, 0x26, 0x46, 0x66,
    0xF0, 0x89, 0x9C, 0xA8, 0x29, 0x51, 0x79, 0x24, 0x70, 0x59, 0x44, 0x69, 0x38, 0x64, 0x48, 0x31,
    0xA9, 0x88, 0x09, 0x20, 0x59, 0x70, 0xAB, 0x11, 0x38, 0x40, 0x69, 0xA8, 0x19, 0x31, 0x48, 0x60,
    0x8C, 0xA8, 0x3C, 0x41, 0x5C, 0x20, 0x7C, 0x00, 0xF1, 0x87, 0x98, 0x19, 0x86, 0xA8, 0x6E, 0x76,
    0x7E, 0xA9, 0x99, 0x88, 0x2D, 0x55, 0x7D, 0x9E, 0xB9, 0xA3, 0x8A, 0x22, 0x8A, 0x6E, 0x8A, 0x56,
    0x8A, 0x5E, 0x9F, 0xB1, 0x83, 0x06, 0x26, 0x46, 0x66, 0x0E, 0x2E, 0x4E, 0x6E, 0x9D, 0xB8, 0xAD,
    0x00, 0x2C, 0x54, 0x7C, 0xF2, 0xB1, 0x8C, 0xB4, 0x99, 0xB9, 0xA3, 0x2D, 0x55, 0x7D, 0x81, 0x91,
    0xAC, 0x38, 0xAD, 0x3A, 0xB5, 0x83, 0x91, 0xAC, 0x2D, 0xD9, 0x28, 0xD8, 0x4D, 0xD9, 0x48, 0xD8,
    0x6D, 0xD9, 0x68, 0xD8, 0x8C, 0x9D, 0xAE, 0x29, 0xD9, 0x04, 0xAE, 0xD8, 0x51, 0xD9, 0x04, 0xAE,
    0xD8, 0x79, 0xD9, 0x04, 0xD8, 0x81, 0xF3, 0x9D, 0xAD, 0x00, 0x8D, 0xAE, 0x19, 0x81, 0xAD, 0xD9,
    0x01, 0xD8, 0xF2, 0xAE, 0xDA, 0x26, 0xD8, 0x8E, 0x91, 0x29, 0x83, 0xA7, 0xD9, 0xAD, 0xAD, 0xAD,
    0xAD, 0xF3, 0x2A, 0xD8, 0xD8, 0xF1, 0xB0, 0xAC, 0x89, 0x91, 0x3E, 0x5E, 0x76, 0xF3, 0xAC, 0x2E,
    0x2E, 0xF1, 0xB1, 0x8C, 0x5A, 0x9C, 0xAC, 0x2C, 0x28, 0x28, 0x28, 0x9C, 0xAC, 0x30, 0x18, 0xA8,
    0x98, 0x81, 0x28, 0x34, 0x3C, 0x97, 0x24, 0xA7, 0x28, 0x34, 0x3C, 0x9C, 0x24, 0xF2, 0xB0, 0x89,
    0xAC, 0x91, 0x2C, 0x4C, 0x6C, 0x8A, 0x9B, 0x2D, 0xD9, 0xD8, 0xD8, 0x51, 0xD9, 0xD8, 0xD8, 0x79,
    // bank 7, 138 bytes (remainder)
    0xD9, 0xD8, 0xD8, 0xF1, 0x9E, 0x88, 0xA3, 0x31, 0xDA, 0xD8, 0xD8, 0x91, 0x2D, 0xD9, 0x28, 0xD8,
    0x4D, 0xD9, 0x48, 0xD8, 0x6D, 0xD9, 0x68, 0xD8, 0xB1, 0x83, 0x93, 0x35, 0x3D, 0x80, 0x25, 0xDA,
    0xD8, 0xD8, 0x85, 0x69, 0xDA, 0xD8, 0xD8, 0xB4, 0x93, 0x81, 0xA3, 0x28, 0x34, 0x3C, 0xF3, 0xAB,
    0x8B, 0xF8, 0xA3, 0x91, 0xB6, 0x09, 0xB4, 0xD9, 0xAB, 0xDE, 0xFA, 0xB0, 0x87, 0x9C, 0xB9, 0xA3,
    0xDD, 0xF1, 0xA3, 0xA3, 0xA3, 0xA3, 0x95, 0xF1, 0xA3, 0xA3, 0xA3, 0x9D, 0xF1, 0xA3, 0xA3, 0xA3,
    0xA3, 0xF2, 0xA3, 0xB4, 0x90, 0x80, 0xF2, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3,
    0xA3, 0xB2, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xB0, 0x87, 0xB5, 0x99, 0xF1, 0xA3, 0xA3, 0xA3,
    0x98, 0xF1, 0xA3, 0xA3, 0xA3, 0xA3, 0x97, 0xA3, 0xA3, 0xA3, 0xA3, 0xF3, 0x9B, 0xA3, 0xA3, 0xDC,
    0xB9, 0xA7, 0xF1, 0x26, 0x26, 0x26, 0xD8, 0xD8, 0xFF
};
uint8 dmpcfgupddata[192] = {
//  dmp config
//  BANK    OFFSET  LENGTH  [DATA]
    0x03,   0x7B,   0x03,   0x4C, 0xCD, 0x6C,
    0x03,   0xAB,   0x03,   0x36, 0x56, 0x76,
    0x00,   0x68,   0x04,   0x02, 0xCB, 0x47, 0xA2,
    0x02,   0x18,   0x04,   0x00, 0x05, 0x8B, 0xC1,
    0x01,   0x0C,   0x04,   0x00, 0x00, 0x00, 0x00,
    0x03,   0x7F,   0x06,   0x0C, 0xC9, 0x2C, 0x97, 0x97, 0x97,
    0x03,   0x89,   0x03,   0x26, 0x46, 0x66,
    0x00,   0x6C,   0x02,   0x20, 0x00,
    0x02,   0x40,   0x04,   0x00, 0x00, 0x00, 0x00,
    0x02,   0x44,   0x04,   0x00, 0x00, 0x00, 0x00,
    0x02,   0x48,   0x04,   0x00, 0x00, 0x00, 0x00,
    0x02,   0x4C,   0x04,   0x00, 0x00, 0x00, 0x00,
    0x02,   0x50,   0x04,   0x00, 0x00, 0x00, 0x00,
    0x02,   0x54,   0x04,   0x00, 0x00, 0x00, 0x00,
    0x02,   0x58,   0x04,   0x00, 0x00, 0x00, 0x00,
    0x02,   0x5C,   0x04,   0x00, 0x00, 0x00, 0x00,
    0x02,   0xBC,   0x04,   0x00, 0x00, 0x00, 0x00,
    0x01,   0xEC,   0x04,   0x00, 0x00, 0x40, 0x00,
    0x03,   0x7F,   0x06,   0x0C, 0xC9, 0x2C, 0x97, 0x97, 0x97,
    0x04,   0x02,   0x03,   0x0D, 0x35, 0x5D,
    0x04,   0x09,   0x04,   0x87, 0x2D, 0x35, 0x3D,
    0x00,   0xA3,   0x01,   0x00,
    0x00,   0x00,   0x00,   0x01,   //这里是开启DMP的特殊中断的
    //原程序中此行代码为(这里不一定错)
    //0x00,   0x00,   0x00,   0x01,  即LENGTH=0x00，有错

    0x07,   0x86,   0x01,   0xFE,
    0x07,   0x41,   0x05,   0xF1, 0x20, 0x28, 0x30, 0x38,
    0x07,   0x7E,   0x01,   0x30,
    0x07,   0x46,   0x01,   0x9A,
    0x07,   0x47,   0x04,   0xF1, 0x28, 0x30, 0x38,
    0x07,   0x6C,   0x04,   0xF1, 0x28, 0x30, 0x38,
    0x02,   0x16,   0x02,   0x00, 0x01,
/* 上行最后一个数据调整FIFO rate :0x01=100HZ,0x02=66HZ,0x03=50HZ ,0x04=40HZ,0x05=33.33HZ,
// 可从 datasheet 公式推算
//dmp updates
    0x01,   0xB2,   0x02,   0xFF, 0xFF,
    0x01,   0x90,   0x04,   0x09, 0x23, 0xA1, 0x35,
    0x01,   0x6A,   0x02,   0x06, 0x00,
    0x01,   0x60,   0x08,   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00,   0x60,   0x04,   0x40, 0x00, 0x00, 0x00,
    0x01,   0x62,   0x02,   0x00, 0x00,
    0x00,   0x60,   0x04,   0x00, 0x40, 0x00, 0x00*/
};
uint8 dmpUpdates[47]={

    0x01,   0xB2,   0x02,   0xFF, 0xFF,
    0x01,   0x90,   0x04,   0x09, 0x23, 0xA1, 0x35,
    0x01,   0x6A,   0x02,   0x06, 0x00,
    0x01,   0x60,   0x08,   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00,   0x60,   0x04,   0x40, 0x00, 0x00, 0x00,
    0x01,   0x62,   0x02,   0x00, 0x00,
    0x00,   0x60,   0x04,   0x00, 0x40, 0x00, 0x00

};

void _MPU6050_Write_Byte(uint8 reg, uint8 data) {
    EI2C_Mem_Write(&MPU6050_I2C_Struct, MPU6050_ADDR, reg, &data, 1);
}

void _MPU6050_Write_Bit(uint8 reg, uint8 bitNum, uint8 data) {
    uint8 currentData;
    EI2C_Mem_Read(&MPU6050_I2C_Struct, MPU6050_ADDR, reg, &currentData, 1);
    if (data) {
        currentData |= (1 << bitNum);
    } else {
        currentData &= ~(1 << bitNum);
    }
    EI2C_Mem_Write(&MPU6050_I2C_Struct, MPU6050_ADDR, reg, &currentData, 1);
}

void _MPU6050_Write_Bits(uint8 reg, uint8 bitStart, uint8 length, uint8 data) {
    uint8 currentData = 0;
    EI2C_Mem_Read(&MPU6050_I2C_Struct, MPU6050_ADDR, reg, &currentData, 1);
    uint8 mask = ((1 << length) - 1) << (bitStart - length + 1);
    currentData &= ~mask; // Clear the bits
    currentData |= (data << (bitStart - length + 1)) & mask; // Set the bits
    EI2C_Mem_Write(&MPU6050_I2C_Struct, MPU6050_ADDR, reg, &currentData, 1);
}

void _MPU6050_Read(uint8 reg, uint16 length, uint8 *data) {
    EI2C_Mem_Read(&MPU6050_I2C_Struct, MPU6050_ADDR, reg, data, length);
}

void _MPU6050_Read_Bit(uint8 reg, uint8 bitNum, uint8 *data) {
    uint8 currentData;
    EI2C_Mem_Read(&MPU6050_I2C_Struct, MPU6050_ADDR, reg, &currentData, 1);
    *data = currentData & (1 << bitNum);
}

void _MPU6050_Read_Bits(uint8 reg, uint8 bitStart, uint8 length, uint8 *data) {
    uint8 currentData = 0;
    EI2C_Mem_Read(&MPU6050_I2C_Struct, MPU6050_ADDR, reg, &currentData, 1);
    uint8 mask = ((1 << length) - 1) << (bitStart - length + 1);
    currentData &= mask;
    currentData >>= (bitStart - length + 1);
    *data = currentData;
}

uint8 _MPU6050_Load_Firmware() {
    uint32 datanum=0;  //DMP固件写入标志位
    uint8 ye,i;
    uint8 bank=0;   //段（256个数据一段）
    uint8 addr=0;

    for(;bank<8;bank++)
    {
        if(bank == 7)   //这里的作用就是区分最后一段数据
            i = 8;
        else
            i = 16;
        for(ye=0;ye<i;ye++)
        {
            _MPU6050_Write_Byte(0x6d,bank);
            _MPU6050_Write_Byte(0x6e,addr);

            EI2C_Mem_Write(&MPU6050_I2C_Struct, MPU6050_ADDR, 0x6f, dmpmemorydata + datanum, 16);
            datanum += 16;
            addr += 16;
        }
    }
    _MPU6050_Write_Byte(0x6d,7);
    _MPU6050_Write_Byte(0x6e,addr);

    EI2C_Mem_Write(&MPU6050_I2C_Struct, MPU6050_ADDR, 0x6f, dmpmemorydata + datanum, 9);

    OLED_Printf(65,45,6,"%d",datanum + 9);
    OLED_Update();
    return 1;
}

uint8 _MPU6050_Loadcfgupd() {
    uint8 line; //一共需要写入30条设置数据
    uint8 bank; //页
    uint8 datacounts=0; //DMP设置数据标志位
    uint8 bytes2write;  //数据长度。
    uint8 offset;   //偏移地址
//    uint8 writingcounts;    //数据写入标志与bytes2write一同使用
    uint8 special;

    for (line=0;line<30;line++)
    {
        bank=dmpcfgupddata[datacounts++];
        offset=dmpcfgupddata[datacounts++];
        bytes2write=dmpcfgupddata[datacounts++];
        _MPU6050_Write_Byte(0x6d,bank);
        _MPU6050_Write_Byte(0x6e,offset);

        EI2C_Mem_Write(&MPU6050_I2C_Struct, MPU6050_ADDR, 0x6f, dmpcfgupddata + datacounts, bytes2write);

        datacounts += bytes2write;

        if (bytes2write == 0) {
            special = dmpcfgupddata[datacounts++];
            if (special == 0x01) {
                // Enable zero motion interrupt (true);
                // Enable FIFO buffer overflow (true);
                // Enable DMP (true);
                _MPU6050_Write_Byte(0x38, 0x32);
            } else {
                return 0;
            }
        }
    }

    return 1;
}

uint8 _MPU6050_DMP_Updates(uint8 datacounts) {
    uint8 bank, offset, bytes2write;
    bank = dmpUpdates[datacounts++];
    offset = dmpUpdates[datacounts++];
    bytes2write = dmpUpdates[datacounts++];

    _MPU6050_Write_Byte(0x6d, bank);
    _MPU6050_Write_Byte(0x6e, offset);

    EI2C_Mem_Write(&MPU6050_I2C_Struct, MPU6050_ADDR, 0x6f, dmpUpdates + datacounts, bytes2write);

    // datacounts += bytes2write;

    return 1;
}

uint32 MPU6050_Get_FIFO_Count() {
    uint8 i[2];
    EI2C_Mem_Read(&MPU6050_I2C_Struct, MPU6050_ADDR, 0x72, i, 2);
    OLED_Printf(5,45,6,"%d",i[0]);
    OLED_Printf(5,55,6,"%d",i[1]);
    OLED_Update();
    return ((i[0] << 8) + i[1]);
}

uint8 _MPU6050_Read_DMP(uint8 *data) {
    _MPU6050_Read(0x74, 42, data);
    return 1; // Assuming read is always successful
}

void _DMP_Init() {
    uint8 hwRevision,otpValid,mpuIntStatus/*fifoBuffer[128]*/;
    uint8 xgOffsetTC,ygOffsetTC,zgOffsetTC;
    uint32 fifoCount;

    _MPU6050_Write_Bit(0x6A,5,0);   //禁用I2C主模式
    _MPU6050_Write_Bit(0x6B, 7, 1); // Reset MPU6050
    Time_Delay_us(30000);
    _MPU6050_Write_Bit(0x6B,6,0);   //禁止睡眠模式
    _MPU6050_Write_Byte(0x6D,0x70); //写入一个字节数据到0x6d寄存器(选择用户 bank)
    _MPU6050_Write_Byte(0x6E,0x06); //写入一个字节数据到0x6e寄存器(选择存储字节)
    _MPU6050_Read(0x6F,1,&hwRevision);  //读取
    _MPU6050_Write_Byte(0x6D,0);    //重置内存 bank 选择
    _MPU6050_Read_Bit(0x00,0,&otpValid);    //读取 OTP bank 有效标志
    _MPU6050_Read_Bits(0x00,6,6,&xgOffsetTC);   //读陀螺偏置TC值 X
    _MPU6050_Read_Bits(0x01,6,6,&ygOffsetTC);   //读陀螺偏置TC值 Y)
    _MPU6050_Read_Bits(0x02,6,6,&zgOffsetTC);   //读陀螺偏置TC值 Z
    _MPU6050_Write_Byte(0x25,0x7f); //设置从0地址 0x7

    _MPU6050_Write_Byte(0x25,0x68); //这里可能要改。还没有弄明白这里
    _MPU6050_Write_Bit(0x6A,1,1);   //I2C总线主控复位
    Time_Delay_us(20000);
    if((_MPU6050_Load_Firmware()) == 0 ) return;  //加载 DMP代码到内存
    if((_MPU6050_Loadcfgupd()) == 0 ) return; //配制DMP
    _MPU6050_Write_Bits(0x6B,2,3,0x03); //设置时钟脉冲源Z陀螺
    _MPU6050_Write_Byte(0x38,0x32); //设置DMP和FIFO_OFLOW启用中断
    _MPU6050_Write_Byte(0x19,4);    //设置采样率为200 hz  (1khz / (1 + 4) = 200 Hz)
    _MPU6050_Write_Bits(0x1A,5,3,0x1);  //设置外部帧同步TEMP_OUT_L[0]
    _MPU6050_Write_Bits(0x1A,2,3,0x03); //设置DLPF带宽42赫兹
    _MPU6050_Write_Bits(0x1B,4,2,0x03); //陀螺灵敏度设置为+ / - 2000 deg/sec
    _MPU6050_Write_Byte(0x70,0x03); //设置DMP配置字节（功能未知）
    _MPU6050_Write_Byte(0x71,0x00); //设置DMP配置字节（功能未知）
    _MPU6050_Write_Bit(0x00,0,0);   //清除OTP Bank 标志
    _MPU6050_Write_Bits(0x00,6,6,xgOffsetTC);   //设置X 陀螺抵消TCs之前的值
    _MPU6050_Write_Bits(0x01,6,6,ygOffsetTC);   //设置Y 陀螺抵消TCs之前的值
    _MPU6050_Write_Bits(0x02,6,6,zgOffsetTC);   //设置Z 陀螺抵消TCs之前的值
    _MPU6050_DMP_Updates(0);    //最后更新1/7(函数未知)dmpUpdates数组第一行
    _MPU6050_DMP_Updates(5);    //最后更新2/7(函数未知)dmpUpdates数组第二行
    _MPU6050_Write_Bit(0x6A,2,1);   //复位 FIFO
    fifoCount = MPU6050_Get_FIFO_Count();   //读取 FIFO 计数
    //readdmp(fifoCount,fifoBuffer);    //读取FIFO里的数据
    _MPU6050_Write_Bit(0x6A,2,1);   //复位 FIFO

    _MPU6050_Write_Byte(0x1F,2);    //运动检测阈值设置为2
    _MPU6050_Write_Byte(0x21,156);  //零运动检测阈值为156
    _MPU6050_Write_Byte(0x20,80);   //设置运动检测持续时间至80
    _MPU6050_Write_Byte(0x22,0);    //设置零运动检测时间0
    _MPU6050_Write_Bit(0x6A,2,1);   //复位 FIFO
    _MPU6050_Write_Bit(0x6A,6,1);   //使能 FIFO
    _MPU6050_Write_Bit(0x6A,7,1);   //使能 DMP
    _MPU6050_Write_Bit(0x6A,3,1);   //复位 DMP
    _MPU6050_DMP_Updates(12);   //最后更新3/7(函数未知)dmpUpdates数组第三行
    _MPU6050_DMP_Updates(17);   //最后更新4/7(函数未知)dmpUpdates数组第四行
    _MPU6050_DMP_Updates(28);   //最后更新5/7(函数未知)dmpUpdates数组第五行
    while((fifoCount = MPU6050_Get_FIFO_Count()) < 3);  //等待 FIFO 计数 > 2
    _MPU6050_Write_Bit(0x6A,2,1);   //复位 FIFO
    //readdmp(fifoCount,fifoBuffer);    //读取FIFO里的数据
    _MPU6050_Read(0x3A,1,&mpuIntStatus);    //读取中断状态
    _MPU6050_DMP_Updates(35);   //最后更新6/7(函数未知)dmpUpdates数组第六行
    while((fifoCount = MPU6050_Get_FIFO_Count()) < 3);  //等待 FIFO 计数 > 2
    _MPU6050_Write_Bit(0x6A,2,1);   //复位 FIFO
    //readdmp(fifoCount,fifoBuffer);    //读取FIFO里的数据
    _MPU6050_Read(0x3A,1,&mpuIntStatus);    //读取中断状态
    _MPU6050_DMP_Updates(40);   //最后更新7/7(函数未知)dmpUpdates数组第七行
    _MPU6050_Write_Bit(0x6A,7,0);   //禁用DMP(稍后您打开它)
    _MPU6050_Write_Bit(0x6A,2,1);   //复位 FIFO
    _MPU6050_Read(0x3A,1,&mpuIntStatus);

    _MPU6050_Write_Bit(0x6A,2,1);   //复位 FIFO
    _MPU6050_Write_Bit(0x6A,7,1);   //使能 DMP
    return;

}

void MPU6050_Check_DMP_Status() {
    uint8 int_enable, int_status, user_ctrl;

    _MPU6050_Read(0x38, 1, &int_enable);
    _MPU6050_Read(0x3A, 1, &int_status);
    _MPU6050_Read(0x6A, 1, &user_ctrl);

    OLED_Clear();
    OLED_Printf(5, 45, 6, "IntEn:0x%02X", int_enable);
    OLED_Printf(5, 55, 6, "IntSt:0x%02X", int_status);
    OLED_Printf(5, 5, 6, "UserCtrl:0x%02X", user_ctrl);
    OLED_Update();
}



void MPU6050_Init() {
    //port configuration
    MPU6050_I2C_Struct.scl_port = I2C_SCL_PORT;
    MPU6050_I2C_Struct.scl_pin = I2C_SCL_PIN;

    MPU6050_I2C_Struct.sda_port = I2C_SDA_PORT;
    MPU6050_I2C_Struct.sda_pin = I2C_SDA_PIN;

    MPU6050_I2C_Struct.status = EI2C_NOT_READY;

    uint8 data;

    data = 0;
    EI2C_Mem_Write(&MPU6050_I2C_Struct, MPU6050_ADDR, PWR_MGMT_1_REG, &data, 1);
    //Set data rate of 1KHz by writing SMPRT_DIV register
    data = 0x07;
    EI2C_Mem_Write(&MPU6050_I2C_Struct, MPU6050_ADDR, SMPLRT_DIV_REG, &data, 1);
    //Writing both register with 0 to set full scale range
    data = 0x00;
    EI2C_Mem_Write(&MPU6050_I2C_Struct, MPU6050_ADDR, ACCEL_CONFIG_REG, &data, 1);
    EI2C_Mem_Write(&MPU6050_I2C_Struct, MPU6050_ADDR, GYRO_CONFIG_REG, &data, 1);

//    _MPU6050_Write_Bits(0x6B, 2, 3, 0x03); // Set clock source to Z Gyro
//    _MPU6050_Write_Bits(0x1B, 4, 2, 0x03); // Set gyro sensitivity to ±2000 deg/sec
//    _MPU6050_Write_Bits(0x1C, 4, 2, 0x00); // Set accelerometer sensitivity to ±2g

    _DMP_Init(); // Initialize DMP
//    MPU6050_Check_DMP_Status();
    return;
}

EI2C_Status MPU6050_Read_Accel() {
    EI2C_Status retVal = EI2C_OK;
    uint8 Rec_Data[6];
    sint16 Accel_X_RAW, Accel_Y_RAW, Accel_Z_RAW;

    retVal = EI2C_Mem_Read(&MPU6050_I2C_Struct, MPU6050_ADDR, ACCEL_XOUT_H_REG, Rec_Data, 6);
    if (retVal == EI2C_OK) {
        Accel_X_RAW = (sint16) ((uint16) Rec_Data[0] << 8 | Rec_Data[1]);
        Accel_Y_RAW = (sint16) ((uint16) Rec_Data[2] << 8 | Rec_Data[3]);
        Accel_Z_RAW = (sint16) ((uint16) Rec_Data[4] << 8 | Rec_Data[5]);

        accel[0] = Accel_X_RAW * 9.81 / 16384.0 - accel_offset[0];
        accel[1] = Accel_Y_RAW * 9.81 / 16384.0 - accel_offset[1];
        accel[2] = Accel_Z_RAW * 9.81 / 16384.0 - accel_offset[2];
    }
    return retVal;
}

EI2C_Status MPU6050_Read_Gyro() {
    EI2C_Status retVal = EI2C_OK;
    uint8 Rec_Data[6];
    sint16 Gyro_X_RAW, Gyro_Y_RAW, Gyro_Z_RAW;

    retVal = EI2C_Mem_Read(&MPU6050_I2C_Struct, MPU6050_ADDR, GYRO_XOUT_H_REG, Rec_Data, 6);
    if (retVal == EI2C_OK) {
        Gyro_X_RAW = (sint16) ((uint16) Rec_Data[0] << 8 | Rec_Data[1]);
        Gyro_Y_RAW = (sint16) ((uint16) Rec_Data[2] << 8 | Rec_Data[3]);
        Gyro_Z_RAW = (sint16) ((uint16) Rec_Data[4] << 8 | Rec_Data[5]);

        omega[0] = Gyro_X_RAW / 131.0 / 180.0 * 3.1415926 - omega_offset[0];
        omega[1] = Gyro_Y_RAW / 131.0 / 180.0 * 3.1415926 - omega_offset[1];
        omega[2] = Gyro_Z_RAW / 131.0 / 180.0 * 3.1415926 - omega_offset[2];
    }
    return retVal;
}

void _MPU6050_Smooth_Theta() {
    // if(*ang_last>145.0 && *ang_now<-145.0) *ang_state=*ang_state+1;
	// if(*ang_last<-145.0 && *ang_now>145.0) *ang_state=*ang_state-1;
	// return ((*ang_now)+(*ang_state)*360.0);

    static double theta_last[3] = {0, 0, 0};
    static int theta_state[3] = {0, 0, 0};
    for (int i = 0; i < 3; i++) {
        if (theta_last[i] > 145.0 && theta[i] < -145.0) {
            theta_state[i]++;
        } else if (theta_last[i] < -145.0 && theta[i] > 145.0) {
            theta_state[i]--;
        }
        theta[i] += theta_state[i] * 360.0;
        theta_last[i] = theta[i];
    }
}

void MPU6050_Read_Theta() {
    uint8 zd;
    uint32 i = MPU6050_Get_FIFO_Count();
    _MPU6050_Read(0x3A, 1, &zd); // Read interrupt status
    if ((zd & 0x10) || i == 1024) { //
        _MPU6050_Write_Bit(0x6A, 2, 1); // Reset FIFO
    } else if (zd & 0x02) { // If data ready
        uint8 dmpData[42];
        while (i < 42) i = MPU6050_Get_FIFO_Count();
        _MPU6050_Read_DMP(dmpData); // Read DMP data
        // Process quaternion data to calculate theta
        double q0 = ((dmpData[0] << 8) | dmpData[1])/ 16384.0;
        double q1 = ((dmpData[4] << 8) | dmpData[5])/ 16384.0;
        double q2 = ((dmpData[8] << 8) | dmpData[9])/ 16384.0;
        double q3 = ((dmpData[12] << 8) | dmpData[13])/ 16384.0;

        // Convert quaternion to Euler angles (theta)
        theta[0] = atan2(2.0 * (q1 * q2 + q0 * q3),
                        1 - 2.0 * (q2 * q2 + q3 * q3));
        theta[1] = asin(2.0 * (q0 * q2 - q1 * q3)) * 57.3;
        theta[2] = atan2(2.0 * (q0 * q1 + q2 * q3),
                        1 - 2.0 * (q1 * q1 + q2 * q2));
    }
    _MPU6050_Smooth_Theta(); // Smooth theta values
}

void MPU6050_Get_Omega(float *omegaX, float *omegaY, float *omegaZ) {
    *omegaX = omega[0] - omega_offset[0];
    *omegaY = omega[1] - omega_offset[1];
    *omegaZ = omega[2] - omega_offset[2];
}

void MPU6050_Get_Accel(float *accelX, float *accelY, float *accelZ) {
    *accelX = accel[0] - accel_offset[0];
    *accelY = accel[1] - accel_offset[1];
    *accelZ = accel[2] - accel_offset[2];
}

void MPU6050_Get_Theta(float *thetaX, float *thetaY, float *thetaZ) {
    *thetaX = theta[0] - theta_offset[0];
    *thetaY = theta[1] - theta_offset[1];
    *thetaZ = theta[2] - theta_offset[2];
}

void MPU6050_Set_AccelOffset() {
    accel_offset[0] = accel[0];
    accel_offset[1] = accel[1];
    accel_offset[2] = accel[2];
}

void MPU6050_Set_OmegaOffset() {
    omega_offset[0] = omega[0];
    omega_offset[1] = omega[1];
    omega_offset[2] = omega[2];
}

void MPU6050_Set_ThetaOffset() {
    theta_offset[0] = theta[0];
    theta_offset[1] = theta[1];
    theta_offset[2] = theta[2];
}

void MPU6050_Step_Theta(float dt) {
    if (omega[0] > MPU6050_OMEGA_INT_THRESHOLD || omega[0] < -MPU6050_OMEGA_INT_THRESHOLD)
        theta[0] += omega[0] * dt;
    if (omega[1] > MPU6050_OMEGA_INT_THRESHOLD || omega[1] < -MPU6050_OMEGA_INT_THRESHOLD)
        theta[1] += omega[1] * dt;
    if (omega[2] > MPU6050_OMEGA_INT_THRESHOLD || omega[2] < -MPU6050_OMEGA_INT_THRESHOLD)
        theta[2] += omega[2] * dt;
}
